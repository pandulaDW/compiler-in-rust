#![allow(dead_code)]

use crate::{
    ast::{expressions::AllExpressions, statements::AllStatements, AllNodes},
    code::{self, make, Opcode, OP_CONSTANT},
    object::{objects::Integer, AllObjects},
};
use anyhow::anyhow;

pub struct Compiler {
    /// instructions will hold the generated bytecode
    instructions: code::Instructions,

    /// constants is a slice that serves as our constant pool.
    constants: Vec<AllObjects>,
}

impl Compiler {
    pub fn new() -> Self {
        Self {
            instructions: vec![],
            constants: vec![],
        }
    }

    pub fn compile(&mut self, node: AllNodes) -> anyhow::Result<()> {
        match node {
            AllNodes::Program(p) => {
                for stmt in p.statements {
                    if let Err(e) = self.compile(AllNodes::Statements(stmt)) {
                        return Err(e);
                    }
                }
            }
            AllNodes::Statements(stmt) => match stmt {
                AllStatements::Expression(expr_stmt) => {
                    let Some(expr) = expr_stmt.expression else {
                        return Err(anyhow!("expression statement should contain an expression"));
                    };
                    return self.compile(AllNodes::Expressions(*expr));
                }
                _ => todo!(),
            },
            AllNodes::Expressions(expr) => match expr {
                AllExpressions::IntegerLiteral(v) => {
                    let integer = AllObjects::Integer(Integer { value: v.value });
                    let constant_index = self.add_constant(integer);
                    self.emit(OP_CONSTANT, &[constant_index]);
                }
                AllExpressions::InfixExpression(expr) => {
                    let Some(left) = expr.left else {
                        return Err(anyhow!("infix expression should contain a left expression"));
                    };
                    if let Err(e) = self.compile(AllNodes::Expressions(*left)) {
                        return Err(e);
                    };

                    let Some(right) = expr.right else {
                        return Err(anyhow!("infix expression should contain a right expression"));
                    };
                    if let Err(e) = self.compile(AllNodes::Expressions(*right)) {
                        return Err(e);
                    };
                }
                _ => todo!(),
            },
        }
        Ok(())
    }

    /// Compiler terminology for `generate` and `output`. It generates an instruction and add it to the results,
    /// either by printing it, writing it to a file or by adding it to a collection in memory.
    ///
    /// The latter will be done here and the starting position of the just-emitted instruction will be returned.
    fn emit(&mut self, op: Opcode, operands: &[usize]) -> usize {
        let instructions = make(op, operands);
        let current_position = self.instructions.len();
        self.instructions.extend_from_slice(&instructions);
        current_position
    }

    /// Add the given constant to the constant pool and return it's index position
    fn add_constant(&mut self, obj: AllObjects) -> usize {
        self.constants.push(obj);
        self.constants.len() - 1
    }

    /// Emits the byte-code instructions after compilation has finished
    pub fn byte_code(self) -> ByteCode {
        ByteCode {
            instructions: self.instructions,
            constants: self.constants,
        }
    }
}

/// Bytecode is what weâ€™ll pass to the VM
pub struct ByteCode {
    pub instructions: code::Instructions,
    pub constants: Vec<AllObjects>,
}

#[cfg(test)]
mod tests {
    use super::code::*;
    use super::test_helpers::*;

    #[test]
    fn test_integer_arithmetic() {
        use Literal::Int;

        let test_cases = vec![(
            "11 + 25",
            vec![Int(11), Int(25)],
            vec![make(OP_CONSTANT, &[0]), make(OP_CONSTANT, &[1])],
        )];

        run_compiler_tests(test_cases);
    }

    #[test]
    fn test_instructions_string() {
        let instructions = vec![
            make(OP_CONSTANT, &[1]),
            make(OP_CONSTANT, &[2]),
            make(OP_CONSTANT, &[65535]),
        ];

        let expected = "0000 OpConstant 1
0003 OpConstant 2
0006 OpConstant 65535
";

        let concatted = concat_instructions(instructions);
        assert_eq!(expected, instructions_to_string(&concatted));
    }

    #[test]
    fn test_read_operands() {
        // op, operands, bytes_read
        let test_cases = [(OP_CONSTANT, [65535], 2)];

        for tc in test_cases {
            let instruction = make(tc.0, &tc.1);
            let def = lookup(tc.0).unwrap();

            let (operands_read, n) = read_operands(&def, &instruction[1..]);
            assert_eq!(n, tc.2);

            for (i, want) in tc.1.into_iter().enumerate() {
                assert_eq!(want, operands_read[i]);
            }
        }
    }
}

#[cfg(test)]
pub mod test_helpers {
    use super::{code::Instructions, Compiler};
    use crate::{ast::program::Program, lexer::Lexer, object::AllObjects, parser::Parser};

    pub enum Literal {
        Int(i64),
    }

    // input, expectedConstants, expectedInstructions
    type CompilerTestCase<'a> = (&'a str, Vec<Literal>, Vec<Instructions>);

    pub fn run_compiler_tests(test_cases: Vec<CompilerTestCase>) {
        for tc in test_cases {
            let program = parse(tc.0);
            let mut compiler = Compiler::new();
            if let Err(e) = compiler.compile(program.make_node()) {
                panic!("compiler error: {e}");
            };

            let bytecode = compiler.byte_code();
            test_instructions(tc.2, bytecode.instructions);
            test_constants(tc.1, bytecode.constants);
        }
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concatted = concat_instructions(expected);
        assert_eq!(concatted.len(), actual.len());

        for (i, ins) in concatted.into_iter().enumerate() {
            assert_eq!(actual[i], ins);
        }
    }

    fn test_constants(expected: Vec<Literal>, actual: Vec<AllObjects>) {
        assert_eq!(expected.len(), actual.len());

        for (i, constant) in expected.into_iter().enumerate() {
            match constant {
                Literal::Int(v) => test_integer_object(v, &actual[i]),
            }
        }
    }

    pub fn concat_instructions(s: Vec<Instructions>) -> Instructions {
        s.iter().fold(Vec::new(), |mut out, ins| {
            out.extend_from_slice(ins);
            out
        })
    }

    pub fn test_integer_object(expected: i64, actual: &AllObjects) {
        match actual {
            AllObjects::Integer(v) => assert_eq!(v.value, expected),
            _ => panic!("expected an integer object"),
        };
    }

    pub fn parse(input: &str) -> Program {
        let l = Lexer::new(input);
        let mut p = Parser::new(l);
        p.parse_program()
    }
}
