#![allow(dead_code)]

use crate::{ast::program::Program, code, object};

struct Compiler {
    /// instructions will hold the generated bytecode
    instructions: code::Instructions,

    /// constants is a slice that serves as our constant pool.
    constants: Vec<object::AllObjects>,
}

impl Compiler {
    fn new() -> Self {
        Self {
            instructions: vec![],
            constants: vec![],
        }
    }

    fn compile(&mut self, _program: Program) -> anyhow::Result<()> {
        Ok(())
    }

    fn byte_code(self) -> ByteCode {
        ByteCode {
            instruction: self.instructions,
            constants: self.constants,
        }
    }
}

/// Bytecode is what weâ€™ll pass to the VM
struct ByteCode {
    instruction: code::Instructions,
    constants: Vec<object::AllObjects>,
}

#[cfg(test)]
mod tests {
    use crate::code::{read_operands, Definition};

    use super::code::{instructions_to_string, make, OP_CONSTANT};
    use super::test_helpers::*;

    #[test]
    fn test_integer_arithmetic() {
        use Literal::Int;

        let test_cases = vec![(
            "1 + 2",
            vec![Int(1), Int(2)],
            vec![make(OP_CONSTANT, &[0]), make(OP_CONSTANT, &[1])],
        )];

        run_compiler_tests(test_cases);
    }

    #[test]
    fn test_instructions_string() {
        let instructions = vec![
            make(OP_CONSTANT, &[1]),
            make(OP_CONSTANT, &[2]),
            make(OP_CONSTANT, &[65535]),
        ];

        let expected = "0000 OpConstant 1
        0003 OpConstant 2
        0006 OpConstant 65535";

        let concatted = concat_instructions(instructions);
        assert_eq!(expected, instructions_to_string(&concatted));
    }

    #[test]
    fn test_read_operands() {
        // op, operands, bytes_read
        let test_cases = [(OP_CONSTANT, [65535], 2)];

        for tc in test_cases {
            let instruction = make(tc.0, &tc.1);
            let def = Definition::lookup(tc.0).unwrap();

            let (operands_read, n) = read_operands(&def, &instruction[1..]);
            assert_eq!(n, tc.2);

            for (i, want) in tc.1.into_iter().enumerate() {
                assert_eq!(want, operands_read[i]);
            }
        }
    }
}

#[cfg(test)]
mod test_helpers {
    use super::{code::Instructions, Compiler};
    use crate::{ast::program::Program, lexer::Lexer, object::AllObjects, parser::Parser};

    pub enum Literal {
        Int(i64),
    }

    // input, expectedConstants, expectedInstructions
    type CompilerTestCase<'a> = (&'a str, Vec<Literal>, Vec<Instructions>);

    pub fn run_compiler_tests(test_cases: Vec<CompilerTestCase>) {
        for tc in test_cases {
            let program = parse(tc.0);
            let mut compiler = Compiler::new();
            if let Err(e) = compiler.compile(program) {
                panic!("compiler error: {e}");
            };

            let bytecode = compiler.byte_code();
            test_instructions(tc.2, bytecode.instruction);
            test_constants(tc.1, bytecode.constants);
        }
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concatted = concat_instructions(expected);
        assert_eq!(concatted.len(), actual.len());

        for (i, ins) in concatted.into_iter().enumerate() {
            assert_eq!(actual[i], ins);
        }
    }

    fn test_constants(expected: Vec<Literal>, actual: Vec<AllObjects>) {
        assert_eq!(expected.len(), actual.len());

        for (i, constant) in expected.into_iter().enumerate() {
            match constant {
                Literal::Int(v) => test_integer_object(v, &actual[i]),
            }
        }
    }

    pub fn concat_instructions(s: Vec<Instructions>) -> Instructions {
        let mut out = Vec::new();
        for ins in s {
            out.extend_from_slice(&ins);
        }
        out
    }

    fn test_integer_object(expected: i64, actual: &AllObjects) {
        match actual {
            AllObjects::Integer(v) => assert_eq!(v.value, expected),
            _ => panic!("expected an integer object"),
        };
    }

    fn parse(input: &str) -> Program {
        let l = Lexer::new(input);
        let mut p = Parser::new(l);
        p.parse_program()
    }
}
