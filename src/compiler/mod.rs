mod compile;

use crate::{
    code::{self, make, Opcode},
    object::AllObjects,
};

pub struct Compiler {
    /// instructions will hold the generated bytecode
    instructions: code::Instructions,

    /// constants is a slice that serves as our constant pool.
    constants: Vec<AllObjects>,
}

impl Compiler {
    /// Creates a new compiler with empty instructions and constant pool.
    pub fn new() -> Self {
        Self {
            instructions: vec![],
            constants: vec![],
        }
    }

    /// Compiler terminology for `generate` and `output`. It generates an instruction and add it to the results,
    /// either by printing it, writing it to a file or by adding it to a collection in memory.
    ///
    /// The latter will be done here and the starting position of the just-emitted instruction will be returned.
    fn emit(&mut self, op: Opcode, operands: &[usize]) -> usize {
        let instructions = make(op, operands);
        let current_position = self.instructions.len();
        self.instructions.extend_from_slice(&instructions);
        current_position
    }

    /// Add the given constant to the constant pool and return it's index position.
    fn add_constant(&mut self, obj: AllObjects) -> usize {
        self.constants.push(obj);
        self.constants.len() - 1
    }

    /// Emits the byte-code instructions after compilation has finished.
    pub fn byte_code(self) -> ByteCode {
        ByteCode {
            instructions: self.instructions,
            constants: self.constants,
        }
    }
}

/// Bytecode is what gets pass to the VM
pub struct ByteCode {
    pub instructions: code::Instructions,
    pub constants: Vec<AllObjects>,
}

#[cfg(test)]
mod tests {
    use super::code::*;
    use super::test_helpers::*;

    #[test]
    fn test_integer_arithmetic() {
        use Literal::Int;

        let test_cases = vec![(
            "11 + 25",
            vec![Int(11), Int(25)],
            vec![
                make(OP_CONSTANT, &[0]),
                make(OP_CONSTANT, &[1]),
                make(OP_ADD, &[]),
            ],
        )];

        run_compiler_tests(test_cases);
    }
}

#[cfg(test)]
pub mod test_helpers {
    use super::{code::Instructions, Compiler};
    use crate::{ast::program::Program, lexer::Lexer, object::AllObjects, parser::Parser};

    pub enum Literal {
        Int(i64),
    }

    // input, expectedConstants, expectedInstructions
    type CompilerTestCase<'a> = (&'a str, Vec<Literal>, Vec<Instructions>);

    pub fn run_compiler_tests(test_cases: Vec<CompilerTestCase>) {
        for tc in test_cases {
            let program = parse(tc.0);
            let mut compiler = Compiler::new();
            if let Err(e) = compiler.compile(program.make_node()) {
                panic!("compiler error: {e}");
            };

            let bytecode = compiler.byte_code();
            test_instructions(tc.2, bytecode.instructions);
            test_constants(tc.1, bytecode.constants);
        }
    }

    fn test_instructions(expected: Vec<Instructions>, actual: Instructions) {
        let concatted = concat_instructions(expected);
        assert_eq!(concatted.len(), actual.len());

        for (i, ins) in concatted.into_iter().enumerate() {
            assert_eq!(actual[i], ins);
        }
    }

    fn test_constants(expected: Vec<Literal>, actual: Vec<AllObjects>) {
        assert_eq!(expected.len(), actual.len());

        for (i, constant) in expected.into_iter().enumerate() {
            match constant {
                Literal::Int(v) => test_integer_object(v, &actual[i]),
            }
        }
    }

    pub fn concat_instructions(s: Vec<Instructions>) -> Instructions {
        s.iter().fold(Vec::new(), |mut out, ins| {
            out.extend_from_slice(ins);
            out
        })
    }

    pub fn test_integer_object(expected: i64, actual: &AllObjects) {
        match actual {
            AllObjects::Integer(v) => assert_eq!(v.value, expected),
            _ => panic!("expected an integer object"),
        };
    }

    pub fn parse(input: &str) -> Program {
        let l = Lexer::new(input);
        let mut p = Parser::new(l);
        p.parse_program()
    }
}
